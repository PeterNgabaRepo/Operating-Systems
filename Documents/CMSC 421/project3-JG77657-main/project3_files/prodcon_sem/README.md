I implemented the delete function by ensuring that there was not a thread waiting to enqueue or dequeue by checking the value of the waiting variable. After passing that condition then the function checked to ensure that the buffer was even initialized before deleting it. If this occurs then we can delete the buffer. This is done by acquiring the lock then iterating through the buffer and freeing every node. After freeing every node we reset the buffer.read and buffer.write to NULL and its length to 0 and destroy all the semaphores.

My test_user_sem.c was the next file I implemented to test that the functions I made worked. First I copied my test_user.c from part 1 to part 2 and changed the function names to the corresponding names and replaced print_buffer with dequeue_buffer. Thus I tested to see if the delete, dequeue and insert buffer functions returned -1 for a FAILED if the buffer was not initialized yet. Upon initialization I used enqueue to insert characters into the array. This part was tricky because I had to remember that I had to use the ASCII value to increment and insert it into arr[i].
 However, once I recalled this information I populated the array with same character value then enqueued and incremented the ASCII value after each enqueue until it was greater than ‘9’ and then set it back to ‘0’. Then I looped through the buffer and dequeued the data and looped inside the greater for loop to print every character from the array to ensure that it worked. Furthermore, I deleted the buffer and attempted to insert into an empty buffer to ensure that did not work either.
Once I ensured that these functions worked correctly I commented the previous tests out and made two new threads which called the producer and consumer fxns then deleted. The producer fxn basically was a for loop which looped 1000 times populating an array of 1024 chars with the same ASCII value from ‘0’ - ‘9’ with a random double between 0 and 1 second used to sleep fxn.
The consumer fxn was similar but opposite. I used a for loop, looping 1000 times and a random double between 0 and 1 second to sleep and dequeued the data. All the print statements for the semaphores and data took place in the actual enqueue and dequeue functions to ensure that it synchronized correctly and printed in the mutex and semaphore. 

To implement these files in kernel space I copied the buffer_user_sem.c to buffer_sem.c and included the linux header files required. Furthermore, I changed the function headers to SYSCALL_DEFINE(# of parameters)(fxn name, param type, param name). Then I changed the for loops to make int i; go outside of the for loop and changed all printf to printk, free to kfree and malloc to kmalloc. Furthermore, I had to remove the semaphore.h header and include the kernel version. Then I initialized the semaphores in kernel space and used the corresponding sema_init fxns and down and ups to replace sem_wait and sem_post and commented out print_semaphores(). 
I moved those functions to the syscall definitions and syscall table, I also added the file locations to the kernel makefile. Then I compiled the kernel, installed it, rebooted it and checked uname -a. Then I made the test_sem.c file by copying test_user_sem.c to test_sem.c I defined the global variables with the corresponding sys call table number and replaced all function calls with the syscall(# of sys call) and used sudo dmesg to ensure that the outputs were correct. In order to successfully compile it I needed to add a rule to makefile for obj.y = buffer_sem.o but also test_sem rule to compile with the pthreads, $(CXX) test_sem.c -o test_sem $(CXXFLAGS)   
